# Звіт з лабораторної роботи (GitHub Actions)

## Коротко про запуски

**Запуск 1 (умовно безпечний код)**
- Дата/час: **2026-01-04 21:54:15 UTC**
- Run ID: **20699670453**
- Підсумок: **success**
- Особливість: job `sast-report (non-blocking)` (Bandit) завершився з **failure**, але пайплайн не зупинився, бо цей етап налаштований як не блокуючий (`continue-on-error`).

**Запуск 2 (файл `test_app.py` з `bed/`)**
- Дата/час: **2026-01-04 21:58:31 UTC**
- Run ID: **20699711124**
- Підсумок: **failure**
- Де зупинився: **`sast-gate`** (Semgrep). Після цього етапи `test/build/sca/deploy/dast` були **skipped**.

Скріншоти веб‑інтерфейсу GitHub Actions збережені в папці `screenshots/`:
- `screenshots/run1_safe.png`
- `screenshots/run2_bad.png`

---

## Відповіді на запитання

**1) Чому в першому випадку пайплайн завершився успішно?**
Бо всі блокуючі етапи (`sast-gate`, `test`, `build`, `sca`, `deploy`, `dast`) пройшли успішно. Неблокуючий звіт `sast-report` (Bandit) знайшов зауваження низької/середньої важливості, але політика пайплайна дозволяє їх не блокувати.

**2) Чому у другому випадку він зупинився?**
Після заміни `test_app.py` на версію з `bed/` Semgrep виявив порушення політики в етапі `sast-gate`. Це блокуючий гейт, тому пайплайн зупинився відразу (Fail Fast).

**3) У чому різниця між першим і другим випадками?**
Відрізняється лише `test_app.py`: у першому запуску використано «хорошу» версію (без `assert`), у другому — «погану», яка порушує правило Semgrep. Через це перший запуск проходить усі стадії, а другий завершується на SAST‑гейті.

**4) Чи дійсно перший випадок безпечний і немає вразливостей?**
Ні, не повністю. У першому запуску `sast-report` зафіксував зауваження (Bandit), але вони не блокують пайплайн. Це означає, що вразливості можуть існувати, однак їхній рівень вважається не критичним за поточною політикою.

**5) Як це ілюструє принцип fail fast у DevSecOps?**
Пайплайн має окремий блокуючий гейт `sast-gate`. Як тільки з’являється критичне порушення (другий запуск), система зупиняє процес і не витрачає ресурси на подальші етапи (тести, білд, деплой, DAST). Це пришвидшує зворотний зв’язок та економить час команди.
