# Повний звіт за оновленим завданням (аналіз DevSecOps/CI-CD)

## Вхідні дані та докази
- **Успішний запуск (умовно безпечний код)**: GitHub Actions Run ID **20699670453** (2026‑01‑04 21:54:15 UTC), підсумок **success**.
- **Невдалий запуск (код з `bed/`)**: Run ID **20699711124** (2026‑01‑04 21:58:31 UTC), підсумок **failure**.
- **Скріншоти веб‑інтерфейсу GitHub Actions**:
  - `screenshots/run1_safe.png` — успішний запуск.
  - `screenshots/run2_bad.png` — невдалий запуск.

---

# Звіт про практику (Технічна частина)

## Завдання 1: Успіх vs. Провал
**Чому перший запуск успішний, а другий зупинився?**
- У першому запуску використано версію `test_app.py` з папки `good/`. Вона не порушує правило SAST‑гейту Semgrep (політика заборони `assert` у тестах), тому блокуючий етап `sast-gate` проходить, а далі проходять `test`, `build`, `sca`, `deploy`, `dast`.
- У другому запуску використано версію `test_app.py` з папки `bed/`, де є `assert`. Це порушує правило Semgrep у `sast-gate`, тому пайплайн зупиняється одразу після цього етапу (Fail Fast). Усі наступні етапи позначені як **skipped**.

**Ключова різниця**: зміст `test_app.py` — саме він викликає блокування на `sast-gate`. Це видно на скріншотах з інтерфейсу Actions (`screenshots/run1_safe.png` та `screenshots/run2_bad.png`).

---

## Завдання 2: Безпека першого випадку
**Чи є перший випадок абсолютно безпечним?** Ні.

**Чому:**
- Автоматичні сканери не покривають усі типи вразливостей. Наприклад:
  - **Логічні помилки бізнес‑логіки** (неправильні дозволи, підміна замовлень, обхід лімітів) часто не виявляються SAST/SCA.
  - **Конфігураційні ризики** (небезпечні налаштування, поганий CORS, слабкі заголовки безпеки).
  - **0‑day вразливості** або ризики, яких немає у базах CVE.
  - **Секрети/ключі**, які не потрапили у репозиторій (а збережені у CI variables/secret storage) — їх не зловить secret scan.
  - **Динамічні сценарії атак**, які потребують складного інтерактивного тестування.

Таким чином, перший запуск лише показує, що критичних порушень за заданою політикою не знайдено, але **це не означає повної відсутності ризиків**.

---

## Завдання 3: Принцип Fail Fast
**Як подвійний запуск ілюструє fail fast:**
- При появі критичного порушення в `sast-gate` (другий запуск) пайплайн одразу зупиняється і **не витрачає час/ресурси** на тестування, збірку, деплой та DAST.

**Переваги раннього виявлення:**
- **Час**: команда одразу отримує сигнал про проблему, не чекаючи довгого білду.
- **Витрати**: менше обчислювальних ресурсів витрачається на даремні етапи.
- **Якість коду**: швидкий фідбек дозволяє виправляти дефекти ще до інтеграції у реліз.

---

# Огляд пайплайну (Практичний аналіз)

## Завдання 4: Етапи CI/CD
У пайплайні реалізовано такі етапи (послідовність фактична у workflow):

1. **secret-scan**
   - Призначення: пошук витоку секретів у репозиторії.

2. **sast-report (неблокуючий)**
   - Призначення: статичний аналіз коду (Bandit) для збору звіту, **без блокування пайплайна**.

3. **sast-gate (блокуючий)**
   - Призначення: SAST‑гейт (Semgrep) для критичних правил. Якщо порушення є — пайплайн зупиняється.

4. **test**
   - Призначення: виконання юніт‑тестів (`pytest`).

5. **build**
   - Призначення: збірка Docker‑образу застосунку.

6. **sca**
   - Призначення: перевірка залежностей (pip‑audit) + контейнерний скан (Trivy) на вразливості.

7. **deploy**
   - Призначення: запуск контейнера локально в CI‑середовищі для підготовки DAST.

8. **dast**
   - Призначення: динамічний аналіз застосунку (ZAP baseline scan).

---

## Завдання 5: Безпекові сканери
**Сканери та їх призначення:**

- **Secret Scan (Gitleaks)** — виявляє витоки токенів/ключів/паролів у коді.
- **SAST (Bandit)** — аналіз Python‑коду на небезпечні патерни (exec/eval, небезпечні функції, слабкі практики). У нас працює як **звіт** (не блокує).
- **SAST Gate (Semgrep)** — перевіряє критичні правила (у нас правило заборони `assert` у тестах). **Блокує пайплайн**.
- **SCA (pip‑audit)** — шукає відомі CVE у Python‑залежностях.
- **Container Scan (Trivy)** — сканує Docker‑образ на відомі уразливості ОС‑рівня і пакетів.
- **DAST (OWASP ZAP baseline)** — тестує працюючий застосунок на типові веб‑вразливості (XSS, неправильні заголовки, небезпечні конфігурації тощо).

---

## Завдання 6: Реакція на вразливості
**Логіка реагування в пайплайні:**

- **Fail job (блокування):**
  - `secret-scan` — падає, якщо знайдені секрети.
  - `sast-gate` — падає при порушенні критичних правил (Semgrep).
  - `sca` — падає при CVE високої/критичної серйозності у Trivy або при критичних знахідках у pip‑audit.

- **Generate report (звіт без блокування):**
  - `sast-report` (Bandit) — збирає результати, але **не зупиняє** пайплайн.

- **Notify:**
  - У поточному workflow немає окремого кроку «notify» (наприклад, Slack/Email). Фактично повідомлення — це стандартні нотифікації GitHub Actions (email/notifications), або їх можна додати окремим кроком у майбутньому.

---

# Стратегічне планування та покращення

## Завдання 7: Реагування на CVE (аналітичний блок)
**Протокол реагування на високий CVE у залежності (SCA/SBOM):**

1. **Оцінка впливу**
   - Визначити, чи залежність реально використовується (runtime vs dev).
   - Оцінити експлуатаційність (є PoC чи ні, контекст використання).

2. **Пошук рішення**
   - Оновлення залежності до безпечної версії.
   - Якщо оновлення неможливе — заміна бібліотеки або тимчасовий workaround.

3. **Тестування та валідація**
   - Локальні тести + CI‑тести.
   - Перевірка, що оновлення не ламає сумісність.

4. **Розгортання**
   - Реліз через стандартний CI/CD.
   - Моніторинг після деплою.

5. **Документування інциденту**
   - Зафіксувати CVE, версію, рішення, посилання, PR.

6. **Post‑incident аналіз**
   - Чому вразливість з’явилася.
   - Що можна автоматизувати (політики, алерти, SCA‑гейти).

---

## Завдання 8: Автоматизація SBOM‑аналізу
**Як автоматизувати перевірку SBOM на нові CVE:**

- Регулярний **scheduled workflow** (наприклад, щодня/щотижня) для повторного скану SBOM.
- Використання інструментів:
  - **Trivy** — сканує SBOM і контейнерні образи.
  - **Grype** — ефективний для аналізу SBOM (CycloneDX/SPDX).
  - **OSV‑Scanner** — сканує залежності проти бази OSV.

**Ідеальний workflow:**
1. Генерувати SBOM під час build (наприклад, `syft`).
2. Зберігати SBOM як артефакт або у репозиторії релізів.
3. Запускати scheduled‑скан (Trivy/Grype/OSV) проти SBOM.
4. Якщо знайдені нові критичні CVE — створювати issue/alert, запускати процес оновлення.

---

## Завдання 9: Покращення пайплайну (2–3 ідеї)

**Ідея 1 — SARIF‑репорти у вкладку Security**
- **Проблема:** розробники не бачать зручної централізованої картини з результатами сканів.
- **Рішення:** експортувати результати Bandit/Semgrep/Trivy у SARIF і публікувати у GitHub Security.
- **Ефект:** прозорість, швидший фідбек, централізований огляд.

**Ідея 2 — Гнучкі політики безпеки**
- **Проблема:** або все блокується, або все пропускається.
- **Рішення:** розділити рівні важливості (наприклад, блокувати тільки `HIGH/CRITICAL`, а `LOW/MEDIUM` — лише у звітах).
- **Ефект:** баланс між безпекою і швидкістю розробки.

**Ідея 3 — Автоматичні нотифікації**
- **Проблема:** розробники можуть пропустити помилки пайплайну.
- **Рішення:** додати Slack/Email‑сповіщення на fail‑події з коротким резюме.
- **Ефект:** швидша реакція та менше «тихих» помилок.

---

# Висновок
Два запуски чітко демонструють роботу принципу **Fail Fast**: при критичному порушенні пайплайн припиняє роботу, що економить час і ресурси. Перший запуск не означає повної безпеки — автоматичні сканери мають обмеження, тож важливо поєднувати їх з процесами аналізу та реагування. Запропоновані покращення підвищують прозорість та ефективність DevSecOps‑процесів.
