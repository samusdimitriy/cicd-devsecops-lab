# Отчет по лабораторной работе (GitHub Actions)

## Кратко о запусках

**Запуск 1 (условно безопасный код)**
- Дата/время: 2026-01-04 21:54:15 UTC
- Run ID: 20699670453
- Итог: **success**
- Особенности: job `sast-report (non-blocking)` завершился с **failure**, но пайплайн продолжил работу, т.к. этот шаг помечен как не блокирующий (continue-on-error).

**Запуск 2 (файл test_app.py из `bed/`)**
- Дата/время: 2026-01-04 21:58:31 UTC
- Run ID: 20699711124
- Итог: **failure**
- Остановка: **`sast-gate`** (Semgrep) — пайплайн остановился, дальнейшие стадии `test/build/sca/deploy/dast` были **skipped**.

Скриншоты сохранены в папке `screenshots/`:
- `screenshots/run1_safe.png`
- `screenshots/run2_bad.png`
(Текстовые версии — `screenshots/run1_safe.txt` и `screenshots/run2_bad.txt`.)

---

## Ответы на вопросы

**1) Почему в первом случае пайплайн завершился успешно?**
Потому что все блокирующие стадии (`sast-gate`, `test`, `build`, `sca`, `deploy`, `dast`) прошли успешно. Неблокирующий отчет `sast-report` нашел низко/среднеуровневые замечания Bandit, но этот job настроен как `continue-on-error`, поэтому он не останавливает пайплайн.

**2) Почему во втором случае он остановился?**
Во втором запуске файл `test_app.py` был заменен на вариант из `bed/`, что вызвало срабатывание правила Semgrep в блокирующей стадии `sast-gate`. Этот шаг настроен как «fail fast», поэтому пайплайн остановился сразу после выявления критического нарушения политики.

**3) В чем разница между первым и вторым случаями?**
Разница только в содержимом `test_app.py`. В первом случае использовалась «хорошая» версия (без `assert`), во втором — «плохая» версия с `assert`, которая и была зафиксирована как критичная в `sast-gate`. В результате первый запуск прошел все стадии, а второй завершился на SAST.

**4) Действительно ли первый случай безопасный и нет уязвимостей?**
Нет, он не полностью безопасный. В первом запуске `sast-report` (Bandit) зафиксировал замечания низкой/средней важности, но они не блокируют пайплайн. Это показывает, что уязвимости могут присутствовать, просто политика допускает их как «не критичные».

**5) Как это иллюстрирует принцип fail fast в DevSecOps?**
Политика «fail fast» реализована через отдельный SAST-гейт (`sast-gate`). Как только обнаружено критичное нарушение (во втором запуске), пайплайн немедленно останавливается и не тратит ресурсы на тесты, сборку, деплой и DAST. Это ускоряет обратную связь и экономит время команды.
